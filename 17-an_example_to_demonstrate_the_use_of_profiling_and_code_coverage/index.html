<!DOCTYPE html>

<html class="writer-html5" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../img/favicon.ico" rel="shortcut icon"/>
<title>Nuclei Studio使用Profiling功能进行性能调优举例 - Nuclei Studio Supply Documents</title>
<link href="../css/theme.css" rel="stylesheet"/>
<link href="../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<link href="../extra.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Nuclei Studio\u4f7f\u7528Profiling\u529f\u80fd\u8fdb\u884c\u6027\u80fd\u8c03\u4f18\u4e3e\u4f8b";
        var mkdocs_page_input_path = "17-an_example_to_demonstrate_the_use_of_profiling_and_code_coverage.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href=".."> Nuclei Studio Supply Documents
        </a>
</div>
<div aria-label="导航栏" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="..">Home</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../1-cannot-setup-guestmemory/">因内存不足，导致在Nuclei Studio中启动qemu失败</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../2-qemu-glib-gio-unexpectedly/">windows 11下使用Nuclei Studio进行qemu调试程序时报错</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../3-print_memor_usage_in_ide/">How to print memory usage in Nuclei Studio</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../4-use_pre_build_or_post_build/">在编译工程时，使用了Pre-build Command/Post-build Command时报错</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../5-update_npk_to_support_nucleistudio_202310/">升级npk.yml以支持Nuclei Studio 2023.10</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../6-gcc13_gen_rvv_instructions_when_rvv_enabled/">GCC13 auto generated RVV instructions when RVV enabled</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../7-update_nucleistudio_202310_to_fixed_version/">更新 Nuclei Studio 2023.10 到最新修正版本</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../8-openocd_202310_flashloader_flaws/">OpenOCD在操作容量大于16M-Byte的nor-flash时的问题</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../9-modify_the_cproject_file_to_change_the_project_to_gcc13/">通过修改.cproject文件，升级工程工具链到GCC 13</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../10-compiling_projects_with_headless_in_nuclei_studio/">在Nuclei Studio下用命令行编译工程</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../11-openocd_reported_error_not_known_as_fespi_capable/">OpenOCD烧写程序时报错Error:Device ID 8xle2g8a6d is not known as FESPI capable</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../12-nucleisdk-0.5.0-dhrystone-score-lower-than-expected-in-IDE/">关于dhrystone在IDE上跑分和NSDK 0.5.0命令行跑分不一致的问题</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../13-error_could_not_find_an_available_hardware_trigger/">Error: Couldn't find an available hardware trigger / Error: can't add breakpoint: resource not available</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../14-cannot_find_-lncrt_balanced_no_such_file_or_directory/">cannot find -lncrt_balanced: No such file or directory</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../15-unsatisfiedLinkError_of_swt-win32-4965r8_dll_on_windows7/">UnsatisfiedLinkError of swt-win32-4965r8.dll on Windows 7</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../16-incomplete_data_output_when_using_profiling_function/">使用 Profiling 功能时可能遇到的一些问题</a>
</li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal current" href="#">Nuclei Studio使用Profiling功能进行性能调优举例</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="#_1">问题说明</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="#_2">解决方案</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#1">1 环境准备</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#2-profiling">2 Profiling 功能</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#2-call-graph">2 Call Graph 功能</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#3-code-coverage">3 Code coverage 功能</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#4">4 补充</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../18-demonstrate_NICE_VNICE_acceleration_of_the_Nuclei_Model_through_profiling/">通过Profiling展示Nuclei Model NICE/VNICE指令加速</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../19-rapid_verification_of_NICE_VNICE_acceleration_with_Nuclei_Model_and_NICE_Wizard/">Nuclei Model结合Nice Wizard快速验证NICE/VNICE指令加速</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../20-quick_downloads_using_flash_programming/">Flash Programming使用案例</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../21-livewatch_for_monitoring_variables/">Live Watch 功能的使用</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../22-example_for_adding_new_instructions_in_llvm/">在llvm中新增自定义汇编指令教程</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../23-nuclei_debug_map_register_analyze/">如何使用芯来提供的DebugMap寄存器分析错误现场</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../24-example_for_adding_new_instructions_in_binutils/">在binutils中新增自定义汇编指令教程</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../25-nuclei_cross_trigger_in_openocd/">OpenOCD 中 Nuclei 交叉触发功能使用指南</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../26-debugging_support_for_freertos_by_openocd/">OpenOCD对FreeRTOS的调试支持使用指南</a>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../27-debug_with_multiple_ftdi_devices/">如何同时使用多个蜂鸟调试器进行调试</a>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="移动导航栏" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="..">Nuclei Studio Supply Documents</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="文档" class="icon icon-home" href=".."></a></li>
<li class="breadcrumb-item active">Nuclei Studio使用Profiling功能进行性能调优举例</li>
<li class="wy-breadcrumbs-aside">
<a class="icon icon-github" href="https://github.com/Nuclei-Software/nuclei-studio/blob/main/17-an_example_to_demonstrate_the_use_of_profiling_and_code_coverage.md"> 在GitHub上编辑</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main"><a class="md-content__icon pdf-download-btn" download href="../pdf/nuclei_studio_supply.pdf" title="Download"><i class="fa fas fa-download"></i><small> PDF</small></a>
<div class="section" itemprop="articleBody">
<h1 id="nuclei-studioprofiling">Nuclei Studio使用Profiling功能进行性能调优举例<a class="headerlink" href="#nuclei-studioprofiling" title="Permanent link">¶</a></h1>
<blockquote>
<p>文档是基于 Nuclei Studio 的 <strong>2024.06</strong> Windows 版本实测。</p>
</blockquote>
<h2 id="_1">问题说明<a class="headerlink" href="#_1" title="Permanent link">¶</a></h2>
<p>Nuclei Studio 2024.06 提供 Profiling 功能、Call Graph 功能 以及 Code coverage 功能，方便用户使用。 简单描述如下：  </p>
<ul>
<li><strong>Profiling 功能</strong>：基于 binutils gprof 工具，可用于分析函数调用关系、调用次数、以及运行时间；通过 Profiling 抓取热点函数可以用来分析程序的瓶颈，以便进行性能优化。</li>
<li><strong>Call Graph 功能</strong>：基于 Profiling 功能，将函数调用关系、调用次数、以及运行时间用图展示出来，方便开发人员分析。</li>
<li><strong>Code coverage 功能</strong>：基于 gcc 编译器提供 gcov 工具，可用来查看源码文件的代码覆盖率，帮助开发人员确定测试用例是否足够充分，是否覆盖了被测代码的所有分支和路径。</li>
</ul>
<p>在 <a href="https://download.nucleisys.com/upload/files/doc/nucleistudio/Nuclei_Studio_User_Guide.202406.pdf">NucleiStudio_User_Guide.pdf</a> 相关章节对这几个功能已经有较详细的描述，这篇文档以一个例子来展示它们的实际应用。</p>
<h2 id="_2">解决方案<a class="headerlink" href="#_2" title="Permanent link">¶</a></h2>
<h3 id="1">1 环境准备<a class="headerlink" href="#1" title="Permanent link">¶</a></h3>
<p><strong>所需材料：</strong> </p>
<ul>
<li>Nuclei Studio：<a href="https://download.nucleisys.com/upload/files/nucleistudio/NucleiStudio_IDE_202406-win64.zip">NucleiStudio 2024.06</a>，以 Windows 版本为例</li>
<li>用例： 以 <a href="https://sourceforge.net/projects/opencore-amr/files/vo-amrwbenc/vo-amrwbenc-0.1.3.tar.gz/download">AMR-WB-enc</a> 即自适应多速率宽带编码音频算法为例，用户可以移植自己的用例</li>
</ul>
<p><strong>基于 nuclei-sdk v0.6.0 移植 amrwbenc 裸机用例：</strong></p>
<p>打开 Nuclei Studio 建立 amrwbenc 工程，然后移植 amrwbenc 源码，最终用例可正常运行。用户可以移植自己的用例，不同用例移植的细节各不相同，这一步不是这篇文档的重点，略过。</p>
<h3 id="2-profiling">2 Profiling 功能<a class="headerlink" href="#2-profiling" title="Permanent link">¶</a></h3>
<p>Nuclei studio 中 Profiling 功能基于 binutils gprof 工具。编译时需带特定的编译选项 <code>-pg</code> 来编译指定源码文件，编译成功后得到 ELF 文件，
然后在实际开发板上运行并收集需要的 gmon.out 文件，最终在 IDE 上以图形化的方式展示。所以还需要在用例末尾添加 gprof 数据收集代码，有两种方式：</p>
<ul>
<li>方式1：移植 gprof 数据收集代码到自己的工程中，代码可以参考 <a href="https://github.com/Nuclei-Software/nuclei-sdk/tree/master/Components/profiling#readme">Profiling README</a></li>
<li>方式2：基于 Nuclei Studio 中的 Profiling demo 进行改造，即用自己的用例替换掉 Profiling demo 工程的的用例部分</li>
</ul>
<p>下面示例采用后一种方法进行演示：</p>
<p><strong>step1：新建 Profiling demo 工程</strong></p>
<p><code>File-&gt;New-&gt;New Nuclei RISC-V C/C++ Project</code>，选择 <code>Nuclei FPGA Evalution Board-&gt;sdk-nuclei_sdk @0.6.0</code></p>
<p><strong>注意：</strong> Nuclei SDK 需选择 0.6.0 及以后版本才支持 Profiling 与 Code coverage 功能</p>
<p><img alt="建立Profiling demo" src="../asserts/images/17/build_profiling_demo.png"/></p>
<p><strong>step2：基于 Profiling demo 工程移植 amrwbenc 裸机用例</strong></p>
<p>删掉 Profiling demo 工程中 application 中的原始用例，替换成 amrwbenc 用例，形成如下目录结构，并确保能编译成功。 </p>
<p>这里提供本示例使用的工程，有兴趣可以下载使用：<br/>
<a href="https://drive.weixin.qq.com/s?k=ABcAKgdSAFcCRlyEVI">优化前的工程下载链接</a></p>
<p>下载 zip 包后，可以直接导入到 Nuclei Studio 中运行(导入步骤：<code>File-&gt;Import-&gt;Existing Projects into Workspace-&gt;Next-&gt;Select archive file-&gt;选择zip压缩包-&gt;next</code>即可)</p>
<p><img alt="移植amrwbenc用例" src="../asserts/images/17/amrwbenc_demo.png"/></p>
<p><strong>step3：在用例结尾处添加 grof 数据收集代码，并添加 -pg 编译选项，重新编译代码</strong></p>
<p>在 main 函数的结尾处添加 gprof 数据收集代码：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * 代码省略</span>
<span class="cm">     */</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * 在main函数的结尾处添加gprof数据收集代码</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">// TODO this is used for collect gprof and gcov data</span>
<span class="w">    </span><span class="c1">// See Components/profiling/README.md about how to set the IDE project properities</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">gprof_collect</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="w">    </span><span class="n">gprof_collect</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>收集 gprof data 有三种方式，通过入参不同进行区分：</p>
<ul>
<li>gprof_collect(0)：在缓冲区中收集 gprof 或 gcov 数据，在调试程序时可以使用 GDB 脚本转储 gcov 或 gprof 二进制文件</li>
<li>gprof_collect(1)：使用 semihost 直接将 gprof 或 gcov 数据写入文件中</li>
<li>gprof_collect(2)：直接在 Console 或 Serial Terminal 中打印 gcov 或 gprof 数据，然后可以通过IDE中 <code>Parse and Generate HexDump</code> 功能进行解析数据并保存到PC上</li>
</ul>
<p>详情可参考 <a href="https://github.com/Nuclei-Software/nuclei-sdk/tree/master/Components/profiling#readme">Profiling README</a>，这里以将 gprof data 打印到串口（Console 或 Serial Terminal）为例。</p>
<p>对需要进行profiling的代码添加 <code>-pg</code> 编译选项，重新编译代码：</p>
<p><strong>注意：</strong> 选择 application, 对关键代码添加 <code>-pg</code> 编译选项，这个用例只有 C 代码，只对 C 代码添加 <code>-pg</code> 编译选项即可</p>
<p><img alt="add_pg_compile" src="../asserts/images/17/add_pg_compile.png"/></p>
<p><strong>step4：运行程序</strong></p>
<p>有几种方式可以运行程序：</p>
<ul>
<li>qemu 模拟器（不需要硬件，简单跑一下流程，测试结果不准确）</li>
<li>上板测试 （基于定时器采集数据）</li>
<li>基于 xl_cpumodel (Nuclei Near Cycle Model)，参考: <a href="../18-demonstrate_NICE_VNICE_acceleration_of_the_Nuclei_Model_through_profiling/">通过Profiling展示Nuclei Model NICE/VNICE指令加速</a></li>
</ul>
<p>这一篇文章只介绍 qemu 仿真与上板测试两种方式，qemu 收集的数据打印到 Console 口，上板实际运行输出到 Nuclei Studio 的 Serial Terminal 口。</p>
<p><strong>step5：解析 gprof 数据</strong></p>
<p>开始解析 gprof 数据。<strong>注意：</strong> 这一步可能遇到一些问题，解决方法可参考 <a href="../16-incomplete_data_output_when_using_profiling_function/">Profiling与 Code coverage 功能可能遇到的问题</a></p>
<ul>
<li>在 qemu 上测试, log 打印到 Console 口</li>
</ul>
<p><strong>注意</strong>: qemu 仅用来模拟展示，如果希望得到准确的热点函数，需要上板测试。
<img alt="call_prase_tools" src="../asserts/images/17/call_prase_tools.png"/> <br/>
解析完成后，会在当前工程目录下生成 gmon.out，双击打开展示：<br/>
<img alt="profiling_on_qemu" src="../asserts/images/17/profiling_on_qemu.png"/> </p>
<ul>
<li>上板测试</li>
</ul>
<p>上板测试的步骤与 qemu 类似，唯一不同的是 gprof 数据输出到 Serial Terminal 上。  </p>
<p>配置 Serial Terminal:</p>
<p><strong>注意</strong>:如果串口工具已经打开，确保每次运行 gprof 前，清除掉串口打印（鼠标右键-&gt; Clear Terminal），避免对数据解析产生影响。  </p>
<p><img alt="config_uart" src="../asserts/images/17/config_uart.png"/> </p>
<p>同样, 全选 log，右键选择<code>Parse and Generate HexDump</code> 功能，就会在工程文件夹下生成 gmon.out 文件，
刷新工程后，就可以双击打开这个gmon.out 文件。</p>
<p>如下图是在<strong>板子上实际运行</strong>得到的 gprof 数据：  </p>
<p><img alt="profiling_on_fpga" src="../asserts/images/17/profiling_on_fpga.png"/></p>
<p>从而得到 TOP5 热点函数为（实际上板测试）：</p>
<div class="codehilite"><pre><span></span><code><span class="n">cor_h_vec_012</span>
<span class="n">ACELP_4t64_fx</span>
<span class="n">voAWB_Residu</span>
<span class="n">voAWB_Convolve</span>
<span class="n">voAWB_Syn_filt</span>
</code></pre></div>
<p>获得热点函数后，可以从热点函数入手开始优化，优化 TOP 函数往往可以事半功倍。</p>
<p><strong>step6：优化热点函数</strong></p>
<p>有如下几种方法优化热点函数：</p>
<ul>
<li>调节编译器参数，针对整个工程或单独算子使用 O2/O3/Ofast 等优化等级，开启 <code>-finline-functions</code> <code>-funroll-all-loops</code> 等优化选项</li>
<li>针对算法进行优化，使用更好的算法实现热点函数</li>
<li>使用 RISC-V 扩展指令（ RVP/RVV 扩展等）优化</li>
</ul>
<p>这里以 RVP 扩展为例，按照热点函数从高到低，用 RVP 扩展来优化。需要确定所用硬件支持 RVP 扩展。</p>
<p><strong>举例如下：</strong></p>
<p>TOP1 热点函数为 <code>cor_h_vec_012</code>，分析函数，尝试使用 RVP 扩展优化：</p>
<p>如下以 <code>#if defined __riscv_xxldspn3x</code> 隔开的代码表示使用 Nuclei N3 P 扩展指令优化的代码。
其中<code>__RV_DSMALDA</code> 是一条 Nuclei N3 P扩展指令，实现了 一次完成 4 笔 int16 相乘，最后累加，结果存放到 int64 变量中。</p>
<p>这些指令Intrinsic API可参考 <a href="https://github.com/Nuclei-Software/nuclei-sdk/blob/master/NMSIS/Core/Include/core_feature_dsp.h">Nuclei P 扩展指令Intrinsic API</a></p>
<p>具体的RVP指令手册，请联系芯来科技获取。</p>
<p>优化后的工程如下，可以与优化之前的工程做对比，只优化了<code>cor_h_vec_012</code> 算子:</p>
<p><a href="https://drive.weixin.qq.com/s?k=ABcAKgdSAFcpMkNUj4">优化后的工程下载链接</a></p>
<p>使用 Nuclei N3 P 扩展指令优化的代码片段如下：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">cor_h_vec_012</span><span class="p">(</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">h</span><span class="p">[],</span><span class="w">                           </span><span class="cm">/* (i) scaled impulse response                 */</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">vec</span><span class="p">[],</span><span class="w">                         </span><span class="cm">/* (i) scaled vector (/8) to correlate with h[] */</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">track</span><span class="p">,</span><span class="w">                         </span><span class="cm">/* (i) track to use                            */</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">sign</span><span class="p">[],</span><span class="w">                        </span><span class="cm">/* (i) sign vector                             */</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">rrixix</span><span class="p">[][</span><span class="n">NB_POS</span><span class="p">],</span><span class="w">              </span><span class="cm">/* (i) correlation of h[x] with h[x]      */</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">cor_1</span><span class="p">[],</span><span class="w">                       </span><span class="cm">/* (o) result of correlation (NB_POS elements) */</span>
<span class="w">        </span><span class="n">Word16</span><span class="w"> </span><span class="n">cor_2</span><span class="p">[]</span><span class="w">                        </span><span class="cm">/* (o) result of correlation (NB_POS elements) */</span>
<span class="w">        </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Word32</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">corr</span><span class="p">;</span>
<span class="w">    </span><span class="n">Word16</span><span class="w"> </span><span class="o">*</span><span class="n">p0</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">,</span><span class="o">*</span><span class="n">p3</span><span class="p">,</span><span class="o">*</span><span class="n">cor_x</span><span class="p">,</span><span class="o">*</span><span class="n">cor_y</span><span class="p">;</span>
<span class="w">    </span><span class="n">Word32</span><span class="w"> </span><span class="n">L_sum1</span><span class="p">,</span><span class="n">L_sum2</span><span class="p">;</span>
<span class="w">    </span><span class="n">cor_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cor_1</span><span class="p">;</span>
<span class="w">    </span><span class="n">cor_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cor_2</span><span class="p">;</span>
<span class="w">    </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rrixix</span><span class="p">[</span><span class="n">track</span><span class="p">];</span>
<span class="w">    </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rrixix</span><span class="p">[</span><span class="n">track</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">track</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NB_POS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">        </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
<span class="cp">#if defined __riscv_xxldspn3x</span>
<span class="w">        </span><span class="n">Word32</span><span class="w"> </span><span class="n">tmp1</span><span class="p">,</span><span class="w"> </span><span class="n">tmp2</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">sum64_1</span><span class="p">,</span><span class="w"> </span><span class="n">sum64_2</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">p64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_2</span><span class="p">;</span>
<span class="w">        </span><span class="n">sum64_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">sum64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">62</span><span class="o">-</span><span class="n">pos</span><span class="w"> </span><span class="p">;(</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">p64_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">__SIMD64</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">);</span>
<span class="w">            </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">            </span><span class="n">p64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DPACK32</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span><span class="w"> </span><span class="n">tmp1</span><span class="p">);</span>
<span class="w">            </span><span class="n">sum64_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DSMALDA</span><span class="p">(</span><span class="n">sum64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_2</span><span class="p">);</span>

<span class="w">            </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">            </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">            </span><span class="n">p64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DPACK32</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span><span class="w"> </span><span class="n">tmp1</span><span class="p">);</span>
<span class="w">            </span><span class="n">sum64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DSMALDA</span><span class="p">(</span><span class="n">sum64_2</span><span class="p">,</span><span class="w"> </span><span class="n">p64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_2</span><span class="p">);</span>
<span class="w">            </span><span class="n">p2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Word32</span><span class="p">)</span><span class="n">sum64_1</span><span class="p">;</span>
<span class="w">        </span><span class="n">L_sum2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Word32</span><span class="p">)</span><span class="n">sum64_2</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">L_sum2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="o">++</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="w">        </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="n">L_sum2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">        </span><span class="n">corr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">        </span><span class="n">cor_x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vo_mult</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span><span class="w"> </span><span class="n">sign</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p0</span><span class="o">++</span><span class="p">);</span>
<span class="w">        </span><span class="n">corr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">        </span><span class="n">cor_y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vo_mult</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span><span class="w"> </span><span class="n">sign</span><span class="p">[</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p3</span><span class="o">++</span><span class="p">);</span>
<span class="w">        </span><span class="n">pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">STEP</span><span class="p">;</span>

<span class="w">        </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">        </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vec</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
<span class="cp">#if defined __riscv_xxldspn3x</span>
<span class="w">        </span><span class="n">sum64_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">sum64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">62</span><span class="o">-</span><span class="n">pos</span><span class="w"> </span><span class="p">;(</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">p64_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">__SIMD64</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">);</span>
<span class="w">            </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="w">            </span><span class="n">p64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DPACK32</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span><span class="w"> </span><span class="n">tmp1</span><span class="p">);</span>
<span class="w">            </span><span class="n">sum64_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DSMALDA</span><span class="p">(</span><span class="n">sum64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_2</span><span class="p">);</span>

<span class="w">            </span><span class="n">tmp1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="w">            </span><span class="n">tmp2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_PKBB16</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="w">            </span><span class="n">p64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DPACK32</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span><span class="w"> </span><span class="n">tmp1</span><span class="p">);</span>
<span class="w">            </span><span class="n">sum64_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__RV_DSMALDA</span><span class="p">(</span><span class="n">sum64_2</span><span class="p">,</span><span class="w"> </span><span class="n">p64_1</span><span class="p">,</span><span class="w"> </span><span class="n">p64_2</span><span class="p">);</span>
<span class="w">            </span><span class="n">p2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Word32</span><span class="p">)</span><span class="n">sum64_1</span><span class="p">;</span>
<span class="w">        </span><span class="n">L_sum2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Word32</span><span class="p">)</span><span class="n">sum64_2</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">;</span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">L_sum2</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="o">++</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="w">        </span><span class="n">L_sum1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="n">L_sum2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum2</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>

<span class="w">        </span><span class="n">corr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">        </span><span class="n">cor_x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vo_mult</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span><span class="w"> </span><span class="n">sign</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p0</span><span class="o">++</span><span class="p">);</span>
<span class="w">        </span><span class="n">corr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">L_sum2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mh">0x8000</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">        </span><span class="n">cor_y</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vo_mult</span><span class="p">(</span><span class="n">corr</span><span class="p">,</span><span class="w"> </span><span class="n">sign</span><span class="p">[</span><span class="n">pos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">p3</span><span class="o">++</span><span class="p">);</span>
<span class="w">        </span><span class="n">pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">STEP</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这个算子进行 P 扩展优化后，<strong>编译时务必带上</strong> dsp 扩展选项进行编译，如下图所示：</p>
<p><img alt="Alt text" src="../asserts/images/17/set_p_ext_opt.png"/></p>
<p>CLean Project 并重新编译，重新跑一次profiling，可以看到优化效果，<code>cor_h_vec_012</code> 函数占用率有所下降，函数调用时间也有所减少。</p>
<p><img alt="Alt text" src="../asserts/images/17/profiling_on_fpga_opt.png"/></p>
<p><strong>注意：</strong> 上述仅提供简单的示例，用户可以依次对热点函数进行分析并优化，运行过程中由于采样等原因，
导致 TOP 函数分布有所波动，这是正常的，最终精确的分析需要统计最终的总 cycle 数，然后计算提升比。</p>
<h3 id="2-call-graph">2 Call Graph 功能<a class="headerlink" href="#2-call-graph" title="Permanent link">¶</a></h3>
<p>Nuclei Studio 中 Call Graph 主要是通过分析 Profiling 的数据来获取到程序中函数的调用关系。</p>
<p><img alt="call_graph" src="../asserts/images/17/call_graph.png"/></p>
<p>Call Graph 功能包括如下几种视图：</p>
<ul>
<li>Radial View</li>
</ul>
<p>本视图中展示了程序的调用关系。</p>
<p><img alt="Radial View" src="../asserts/images/17/Radial_View.png"/></p>
<ul>
<li>Tree View</li>
</ul>
<p>展示了 Radial View 中所选中的程序的调用关系、耗时所占比率、调用次数等信息；选中某一个函数，可以查看到它的父节点以及子节点等信息。</p>
<p><img alt="Tree View" src="../asserts/images/17/Tree_View.png"/></p>
<ul>
<li>Level View</li>
</ul>
<p>与 Tree View 有点类似，展示了程序的调用关系以及调用次数。</p>
<p><img alt="Level_View" src="../asserts/images/17/Level_View.png"/></p>
<ul>
<li>Aggregate View</li>
</ul>
<p>以方图的方式，非常直观的展示了程序的耗时关系。</p>
<p><img alt="Aggregate View" src="../asserts/images/17/Aggregate_View.png"/></p>
<h3 id="3-code-coverage">3 Code coverage 功能<a class="headerlink" href="#3-code-coverage" title="Permanent link">¶</a></h3>
<p>Nuclei studio 中 Code coverage 功能基于 gcc 编译器提供的 gcov 工具，编译时需带特定的编译选项 <code>-coverage</code> 来编译指定源码文件，编译成功后得到 ELF 文件，然后在实际开发板上运行并收集需要的 coverage 文件(gcda/gcno 文件)，最终在 IDE 上以图形化的方式展示。</p>
<p>使用方法与 Profiling 功能类似，这里仅对不同的地方进行说明：</p>
<p><strong>step1：新建 Profiling demo 工程</strong><br/>
<strong>step2：基于 Profiling demo 工程移植 amrwbenc 裸机用例</strong><br/>
<strong>step3：添加 gcov 数据收集代码，并添加 -coverage 编译选项，重新编译代码</strong> </p>
<p>在main函数的结尾处添加gprof数据收集代码：</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * 代码省略</span>
<span class="cm">     */</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * 在main函数的结尾处添加 gcov 数据收集代码</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">// TODO this is used for collect gprof and gcov data</span>
<span class="w">    </span><span class="c1">// See Components/profiling/README.md about how to set the IDE project properities</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">gcov_collect</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="w">    </span><span class="n">gcov_collect</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>添加<code>-coverage</code>编译选项，重新编译代码：</p>
<p><img alt="add_coverage_compile" src="../asserts/images/17/add_coverage_compile.png"/></p>
<p><strong>step4：运行程序</strong> </p>
<p>可以在qemu中模拟运行，或者上板实际运行都可以（统计覆盖率，不涉及到性能分析，所以使用 qemu 或者上板测试都可以）。  </p>
<p><img alt="prase coverage data" src="../asserts/images/17/prase_coverage_data.png"/> </p>
<p>解析之后，在Debug-&gt;application文件夹下生成了 gcda 与 gcno 文件，双击打开即可  </p>
<p><img alt="coverage_result" src="../asserts/images/17/coverage_result.png"/> </p>
<h3 id="4">4 补充<a class="headerlink" href="#4" title="Permanent link">¶</a></h3>
<ol>
<li>Profiling 与 Code coverage 功能可以同时打开，只需添加一起收集 Profiling 数据与 Code coverage 数据的代码，并在编译时添加 <code>-pg -coverage</code> 编译选项。</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="c1">// TODO this is used for collect gprof and gcov data</span>
<span class="w">    </span><span class="c1">// See Components/profiling/README.md about how to set the IDE project properities</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">gprof_collect</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="w">    </span><span class="k">extern</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">gcov_collect</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">interface</span><span class="p">);</span>
<span class="w">    </span><span class="n">gprof_collect</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">gcov_collect</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p><img alt="add_pg_coverage_compile" src="../asserts/images/17/add_pg_coverage_compile.png"/></p>
<ol>
<li>
<p>使用Profiling可能遇见的问题：</p>
</li>
<li>
<p>片上内存不足，打印日志中有错误打印，gprof/gcov data 需要占用一定大小空间</p>
</li>
<li>Console 或 Terminal 收集的数据不全导致解析数据不正确，需确认数据没有被冲掉，需要调节 Console 或 Terminal 输出大小限制</li>
<li>手动删掉 gmon.out 文件，再次解析，弹出 No files have been generated 错误弹框</li>
</ol>
<p>上述具体解决方法可参考 <a href="../16-incomplete_data_output_when_using_profiling_function/">Profiling与 Code coverage 功能可能遇到的问题</a></p>
</div>
</div><footer>
<div aria-label="页脚导航" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../16-incomplete_data_output_when_using_profiling_function/" title="使用 Profiling 功能时可能遇到的一些问题"><span class="icon icon-circle-arrow-left"></span> 上一章</a>
<a class="btn btn-neutral float-right" href="../18-demonstrate_NICE_VNICE_acceleration_of_the_Nuclei_Model_through_profiling/" title="通过Profiling展示Nuclei Model NICE/VNICE指令加速">下一章 <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
<p>All rights reserved</p>
</div>

  用<a href="https://www.mkdocs.org/">MkDocs</a>构建，使用<a href="https://readthedocs.org">Read the Docs</a>提供的<a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>。
</footer>
</div>
</div>
</section>
</div>
<div aria-label="版本" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span>
<a class="fa fa-github" href="https://github.com/Nuclei-Software/nuclei-studio" style="color: #fcfcfc"> GitHub</a>
</span>
<span><a href="../16-incomplete_data_output_when_using_profiling_function/" style="color: #fcfcfc">« 上一章</a></span>
<span><a href="../18-demonstrate_NICE_VNICE_acceleration_of_the_Nuclei_Model_through_profiling/" style="color: #fcfcfc">下一章 »</a></span>
</span>
</div>
<script src="../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "..";</script>
<script src="../js/theme_extra.js"></script>
<script src="../js/theme.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
